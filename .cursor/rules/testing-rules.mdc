---
description: while creating tests, updating tests
globs: *.test.tsx
alwaysApply: false
---

# Test Creation Rules for Embedded Finance Components

## Test File Structure

### 1. File Organization

- Place test files adjacent to component files with `.test.tsx` extension
- Follow naming pattern: `ComponentName.test.tsx`
- Group related test files in `__tests__` directory for complex components

### 2. Required Imports

```typescript
import { render, screen, waitFor } from "@testing-library/react";
import { userEvent } from "@test-utils";
import { http, HttpResponse } from "msw";
import { server } from "@/msw/server";
// ⚠️ IMPORTANT: Do NOT import QueryClientProvider - EBComponentsProvider already includes it
import { EBComponentsProvider } from "@/core/EBComponentsProvider/EBComponentsProvider";
import { OnboardingContextProvider } from "@/core/OnboardingWizardBasic/OnboardingContextProvider/OnboardingContextProvider";
```

### 3. Test Setup Structure

```typescript
// 1. Mock external dependencies
vi.mock("@/path/to/dependency", () => ({
  useHook: () => ({ mockFunction: vi.fn() }),
}));

// 2. Setup test data
const mockData = {
  // Component-specific mock data
};

// 3. Setup OnboardingContext mock if testing wizard steps
const mockOnboardingContext = {
  initialClientId: "123456789",
  onPostClientResponse: vi.fn(),
  availableJurisdictions: ["US"],
  availableProducts: ["EMBEDDED_PAYMENTS"],
};

// 5. Component render helper
// ⚠️ CRITICAL: Do NOT call server.resetHandlers() in renderComponent()
// Handlers should be set up in tests using server.use() BEFORE calling renderComponent()
const renderComponent = (props = {}) => {
  // ❌ WRONG - Don't reset handlers here (beforeEach already does it)
  // server.resetHandlers();

  // ❌ WRONG - Don't set up handlers here (tests should do it)
  // server.use(...)

  return render(
    <EBComponentsProvider
      apiBaseUrl="/"
      headers={{}}
      contentTokens={{ name: "enUS" }}
      reactQueryDefaultOptions={{
        queries: { retry: false },
      }}
    >
      {/* ⚠️ IMPORTANT: EBComponentsProvider already includes QueryClientProvider */}
      {/* Do NOT wrap with QueryClientProvider again */}
      <ComponentName {...props} />
    </EBComponentsProvider>
  );
};
```

### 4. API Mocking Guidelines

- Use exact OAS endpoint paths without suffixes (e.g., `/clients/:id` instead of `/clients/123`)
- Match response shape to OAS schema definitions
- Use path parameters in endpoints where required (e.g., `:id`, `:requestId`)

## Test Organization

### 1. Test Suite Structure

```typescript
describe("ComponentName", () => {
  beforeEach(() => {
    vi.clearAllMocks();
    // ✅ CORRECT: Reset handlers in beforeEach, not in renderComponent
    server.resetHandlers();
  });

  // Group related tests
  describe("rendering", () => {
    test("renders component with initial state", async () => {
      // Arrange
      renderComponent();

      // Act (if needed)

      // Assert
      expect(await screen.findByText(/expected text/i)).toBeInTheDocument();
    });
  });

  describe("interactions", () => {
    test("handles user input correctly", async () => {
      // Arrange
      renderComponent();

      // Act
      await userEvent.click(screen.getByRole("button", { name: /action/i }));

      // Assert
      expect(screen.getByText(/updated state/i)).toBeInTheDocument();
    });
  });
});
```

### 2. Test Categories to Include

1. Initial Rendering
2. User Interactions
3. Form Validation
4. API Integration
5. Error Handling
6. Loading States
7. Edge Cases
8. Accessibility

## Testing Patterns

### 1. API Integration Testing

```typescript
test("handles API interactions", async () => {
  // ✅ CORRECT: Set up handlers BEFORE calling renderComponent()
  // beforeEach already called server.resetHandlers(), so handlers are clean
  server.use(
    http.post("/documents", () => {
      return HttpResponse.json({ success: true });
    })
  );

  // Now render - handlers are already set up
  renderComponent();

  await userEvent.click(screen.getByRole("button", { name: /submit/i }));

  await waitFor(() => {
    expect(screen.getByText(/success/i)).toBeInTheDocument();
  });
});
```

### 2. Form Validation Testing

```typescript
test("validates form inputs", async () => {
  renderComponent();

  const input = screen.getByLabelText(/field name/i);
  await userEvent.type(input, "invalid");
  await userEvent.click(screen.getByRole("button", { name: /submit/i }));

  expect(await screen.findByText(/error message/i)).toBeInTheDocument();
});
```

### 3. Loading State Testing

```typescript
test("displays loading state", async () => {
  server.use(
    http.get("/clients/:id", async () => {
      await delay(1000);
      return HttpResponse.json(mockData);
    })
  );

  renderComponent();

  expect(screen.getByRole("progressbar")).toBeInTheDocument();
  await waitFor(() => {
    expect(screen.queryByRole("progressbar")).not.toBeInTheDocument();
  });
});
```

## Best Practices

### 1. Query Methods Priority

1. `getByRole` - Preferred for interactive elements
2. `getByLabelText` - For form inputs
3. `findBy*` for elements that appear asynchronously (prefer over `waitFor` + `getBy*`)
4. `getByText` only when text is unique; if repeated, use `getAllBy*` and scope/filter to the right container/label
5. `getByTestId` - Last resort, use sparingly

### 2. Async Testing

- Use `findBy*` for elements that appear asynchronously; avoid wrapping `getBy*` in `waitFor` when a `findBy*` fits
- Use `waitFor` only for multi-step async assertions (e.g., state changes after multiple events)
- Always await user events
- Handle loading states appropriately
- When text appears in multiple places (e.g., payment methods vs review panel), scope queries: use `getAllBy*` then pick the element in the intended container (e.g., a label tied to an input)

### 3. Error Handling

```typescript
test("handles error states", async () => {
  server.use(
    http.get("/clients/:id", () => {
      return HttpResponse.json({ error: "Error message" }, { status: 400 });
    })
  );

  renderComponent();

  expect(await screen.findByText(/error message/i)).toBeInTheDocument();
});
```

### 4. Accessibility Testing

```typescript
test("meets accessibility requirements", async () => {
  const { container } = renderComponent();

  expect(container).toHaveNoViolations();

  // Test keyboard navigation
  const button = screen.getByRole("button");
  button.focus();
  expect(document.activeElement).toBe(button);
});
```

## Test Coverage Requirements

1. Minimum Coverage Thresholds:

   - Statements: 80%
   - Branches: 80%
   - Functions: 80%
   - Lines: 80%

2. Required Test Scenarios:
   - Initial render state
   - All user interactions
   - All API integrations
   - Error states
   - Loading states
   - Form validation
   - Accessibility compliance

## Documentation Requirements

1. Test Description:

   - Clear test names describing the scenario
   - Comments for complex test setup
   - Documentation for mock data structure

2. Test Organization:
   - Group related tests in describe blocks
   - Use consistent naming conventions
   - Document test dependencies

## Maintenance Guidelines

1. Keep tests focused and atomic
2. Update tests when component behavior changes
3. Regularly review and refactor test code
4. Maintain mock data separately
5. Document complex test scenarios

## ⚠️ Critical MSW Handler Setup Pattern

### The Correct Pattern (DO THIS)

```typescript
describe("ComponentName", () => {
  beforeEach(() => {
    vi.clearAllMocks();
    server.resetHandlers(); // ✅ Reset in beforeEach
  });

  test("test name", async () => {
    // ✅ Set up handlers BEFORE renderComponent()
    server.use(http.get("*/api/endpoint", () => HttpResponse.json(mockData)));

    renderComponent(); // Handlers are already set up
    // ... assertions
  });
});
```

### The Wrong Pattern (DON'T DO THIS)

```typescript
const renderComponent = (props = {}) => {
  server.resetHandlers(); // ❌ WRONG - clears handlers set up in tests!
  // ...
};

test('test name', async () => {
  server.use(...); // ❌ This gets cleared by renderComponent()!
  renderComponent(); // ❌ No handlers exist, causes MSW warnings and crashes
});
```

### Why This Matters

- **MSW Handler Timing**: Handlers must exist when components render and make API calls
- **Worker Crashes**: Missing handlers cause "Worker exited unexpectedly" errors
- **Parallel Test Issues**: Handler conflicts cause 99+ test failures in parallel runs
- **Test Isolation**: Each test should set up its own handlers after beforeEach reset

## Troubleshooting Common Test Issues

### 1. MSW "intercepted a request without a matching request handler"

**Symptoms:**

```
[MSW] Warning: intercepted a request without a matching request handler:
  • GET /api/endpoint
```

**Causes:**

- `server.resetHandlers()` called in `renderComponent()` after handlers are set up
- Handlers not set up before component renders
- Handler URL pattern doesn't match actual request

**Solutions:**

1. ✅ Remove `server.resetHandlers()` from `renderComponent()` - use `beforeEach` instead
2. ✅ Set up handlers with `server.use()` BEFORE calling `renderComponent()`
3. ✅ Use wildcard patterns: `'*/api/endpoint'` instead of `'/api/endpoint'`
4. ✅ Check handler is set up for the exact endpoint the component calls

### 2. "Worker exited unexpectedly" Error

**Symptoms:**

```
Error: Worker exited unexpectedly
 ❯ ChildProcess.<anonymous> node_modules/tinypool/dist/index.js:139:34
```

**Causes:**

- Missing MSW handlers causing unhandled promise rejections
- ResizeObserver instances not being cleaned up properly
- Memory leaks from shared state in parallel tests

**Solutions:**

1. ✅ Fix MSW handler setup (see above)
2. ✅ Ensure ResizeObserver cleanup in component unmount
3. ✅ Don't disable test isolation (`--poolOptions.forks.isolate=false`)
4. ✅ Use `beforeEach` to reset state between tests

### 3. Duplicate QueryClientProvider Warning

**Symptoms:**

- Tests pass but warnings about nested QueryClientProvider
- React Query cache conflicts

**Solutions:**

1. ✅ **EBComponentsProvider already includes QueryClientProvider** - don't add another
2. ✅ Remove `QueryClientProvider` wrapper from test setup
3. ✅ Use `reactQueryDefaultOptions` prop on `EBComponentsProvider` for test config

### 4. Tests Pass Individually But Fail in Parallel

**Symptoms:**

- Single test file passes: `yarn test Component.test.tsx`
- Full suite fails: `yarn test:unit`
- Random test failures

**Causes:**

- Shared state between tests
- MSW handlers leaking between tests
- ResizeObserver instances accumulating

**Solutions:**

1. ✅ Ensure `beforeEach` properly resets all state
2. ✅ Use `server.resetHandlers()` in `beforeEach`, not in `renderComponent()`
3. ✅ Don't disable test isolation
4. ✅ Check for global state pollution (singletons, module-level variables)

## Debugging Test Failures Checklist

When tests fail, check:

1. **MSW Handlers:**

   - [ ] Are handlers set up BEFORE `renderComponent()` is called?
   - [ ] Is `server.resetHandlers()` only in `beforeEach`, not in `renderComponent()`?
   - [ ] Do handler URL patterns match actual requests (use `'*/path'` for flexibility)?

2. **Provider Setup:**

   - [ ] Is `EBComponentsProvider` used (includes QueryClientProvider)?
   - [ ] No duplicate `QueryClientProvider` wrapper?
   - [ ] `reactQueryDefaultOptions` set for test config?

3. **Test Isolation:**

   - [ ] `beforeEach` resets all state?
   - [ ] Each test sets up its own handlers?
   - [ ] No shared mutable state between tests?

4. **Async Operations:**

   - [ ] Using `findBy*` for elements that appear asynchronously (preferred)?
   - [ ] Using `waitFor` only for complex/multi-step async assertions?
   - [ ] All user events are awaited?

5. **Component Dependencies:**
   - [ ] All required props provided?
   - [ ] Mock data matches component expectations?
   - [ ] API response shapes match OAS schemas?
